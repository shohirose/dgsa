from typing import Sequence, Union
import numpy as np
from numpy.random import SeedSequence, BitGenerator, Generator

Seed = Union[None, int, Sequence[int], SeedSequence, BitGenerator, Generator]


class DGSA:
    """Distance-based generalized sensitivity analysis.

    Attributes:
        n_bootstraps: Number of bootstrap sampling.
        n_bins: Number of bins in percentiles.
        seed: Seed for numpy.random.
        percentiles: Percentiles where CDF is calculated.
    """

    def __init__(self, n_bootstraps: int = 3000,
                 n_bins: int = 100, seed: Seed = None):
        self.n_bootstraps = n_bootstraps
        self.__n_bins = n_bins
        self.__percentiles = np.linspace(0, 1, n_bins + 1)
        self.seed = seed

    @property
    def n_bins(self):
        return self.__n_bins

    @n_bins.setter
    def n_bins(self, n_bins: int):
        if n_bins is None:
            n_bins = 100
        if n_bins <= 0:
            raise ValueError('n_bins must be positive.')
        self.__n_bins = n_bins
        self.__percentiles = np.linspace(0, 1, n_bins)

    @property
    def percentiles(self):
        return self.__percentiles

    def cdf(self, parameters: np.ndarray) -> np.ndarray:
        """Calculate CDF of given parameters

        Args:
            parameters: A list of parameters in the shape of
                        (n_samples, n_parameters).

        Returns:
            CDF of the given parameters in the shape of
            (n_bins, n_parameters).
        """
        return np.percentile(parameters, self.percentiles, axis=0)

    @staticmethod
    def distances(prior_cdf: np.ndarray,
                  class_conditional_cdf: np.ndarray) -> np.ndarray:
        """Calculate L1-norm distance

        Args:
            prior_cdf: Prior CDF in the shape of (n_bins, n_parameters)
            class_conditional_cdf: Class-conditional CDF in the shape of
                (n_bins, n_paramseters)

        Returns:
            L1-norm distance in the shape of (n_parameters)
        """
        return np.sum(np.abs(class_conditional_cdf - prior_cdf), axis=0)

    def run(self, parameters: np.ndarray, labels: np.ndarray) -> np.ndarray:
        """Perform DGSA

        Args:
            parameters: Parameters in the shape of (n_samples, n_parameters)
            labels: Labels for classes in the shape of (n_samples)

            Labels can be generated by using a clustering algorithm, such as
            sklean_extra.cluster.KMedois.

        Returns:
            Standadized measures of sensitivity.
            Shape is (n_classes, n_parameters)
        """
        prior_cdf = self.cdf(parameters)
        n_samples = parameters.shape[0]
        n_parameters = parameters.shape[1]
        unique_labels = set(labels)
        n_labels = len(unique_labels)

        distances = np.zeros((n_labels, n_parameters))
        for i in unique_labels:
            class_cdf = self.cdf(parameters[labels == i])
            distances[i, :] = self.distances(prior_cdf, class_cdf)

        bootstrapped_distances = np.zeros(
            (self.n_bootstraps, n_labels, n_parameters))
        n_labels = [np.count_nonzero(labels == i) for i in unique_labels]
        rng = np.random.default_rng(self.seed)

        for i in range(self.n_bootstraps):
            for j in unique_labels:
                bootstrapped_parameters = parameters[
                    rng.choice(n_samples, n_labels[j], replace=False)
                ]
                class_cdf = self.cdf(bootstrapped_parameters)
                bootstrapped_distances[i, j, :] = self.distances(
                    prior_cdf,
                    class_cdf
                )

        distances_95 = np.percentile(bootstrapped_distances, 95, axis=0)
        std_measures = distances/distances_95
        return std_measures
